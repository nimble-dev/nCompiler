#' @name writePackage
#' @title Create packages containing compiled elements
#' @export
#' @param ... One or more nClass constructor and nFunction objects to be
#'   compiled into the package.
#' @param pkgName Character string. The name of the package to be written.
#' @param dir Character string. Path to the parent directory in which the main
#'   package directory will be created. If not provided, default is the current
#'   working directory.
#' @param control A named list of control options or a named list of named lists
#'   of control parameters for each object to be compiled. See Details for more.
#' @param modify Logical, default FALSE. Should writing proceed even if the
#'   package exists? If TRUE, elements provided for compilation are added to the
#'   existing package. Existing package elements with the same name as new
#'   elements are overwritten, while elements without name conflicts are
#'   retained. To change the default across multiple calls, use
#'   `set_nOption("modifyPackageContents" = TRUE)`
#' @param memberData A named list of elements to be stored as exported package
#'   data objects.
#' @param roxygen A list of roxygen entries corresponding to the objects being
#'   compiled, indicated either by matching names or (if all objects are
#'   documented) by order. The elements of the list are either character strings
#'   or lists produced by documentNClass.
#' @param roxygenize Logical, default FALSE. Should roxygen be called to produce
#'   documentation pages before package build?
#' @param nClass_full_interface
#'
#' @details
#'
#' `writePackage` is a function for adding compiled nFunctions and nClasses to
#' an R package. `writePackage` handles compilation, documentation, and
#' exporting, so that the resulting R package can call the compiled nFunctions
#' and instantiate members of the nClass without further compilation.
#'
#' The names of the elements exported in the package will match the internal
#' names of the elements as they are passed (the \code{name} field in
#' \code{nFunction} and the \code{classname} field in \code{nClass}), NOT
#' the names of the objects in the R environment.
#'
#' If a nonexistent directory or nonexistent directory is indicated by the
#' arguments \code{dir} and \code{pkgName}, writePackage uses Rcpp's
#' Rcpp.package.skeleton to initialize a directory.
#'
#' If the directory indicated by those two arguments does exist and
#' \code{modify} is \code{TRUE}, then the elements passed to `...` are compiled
#' and added to the package. This process will overwrite existing compiled
#' objects with overlapping names, so can be used to edit and update package
#' elements as well as add new elements.
#'
#' If an uncompilable nFunction or nClass is passed, \code{writePackage} will
#' not error. This will not be caught until the package is built, for example
#' with \code{buildPackage}.
#'

#' @name erasePackage
#' @title Erase packages generated by `nCompiler`.
#' @description Erases all files associated with a package written out by the
#'   `writePackage()` function in nCompiler.
#' @param pkgName The name of the package to be erased
#' @param dir The directory containing the package to be erased
#' @param nCompilerOnly Logical, default TRUE. If TRUE, extra checks are
#'   performed to make sure the target directory is a package generated by
#'   nCompiler. If FALSE, checks are still performed to ensure the target looks
#'   like a package.
#' @param unintall Logical, default FALSE. If TRUE, the package is uninstalled
#'   as well as erased.
#' @export
#' @details
#'
#' \code{erasePackage} is a utility function for erasing a written
#' nCompiler-generated package. It is best thought of as the inverse of
#' \code{writePackage}, not \code{buildPackage}, as it is intended for use with
#' source code.
#'
#' If called on a package directory, all contents of the package and the
#' directory itself will be deleted with \code{unlink}.
#'
#' By default, \code{erasePackage} checks that the directory specified looks
#' like an R package. It simply looks to see if there is a DESCRIPTION file and
#' a NAMESPACE file in the directory. If not, \code{erasePackage} errors out.
#' This prevents accidental erasure of important directories.
#'
#' If \code{nCompilerOnly} is \code{TRUE} (the default), the DESCRIPTION file
#' will be checked to make sure it looks like one autogenerated by
#' \code{writePackage}.
#'
#' @examples
#'
#' # Initialize an example nFunction
#' foo <- nFunction(name = "foo",
#'                  fun = function(x = numericScalar()) {
#'                      ans <- x+1
#'                      return(ans)
#'                      returnType(numericScalar())
#'                  })
#' # Write a package containing the compiled nFunction "foo"
#' writePackage(foo,
#'              dir = tempdir(),
#'              pkgName = "fooPackage",
#'              control = list(export = TRUE))
#' # Decide we don't want fooPackage after all and erase it.
#' erasePackage("fooPackage", dir = tempdir())
#' dir.exists(file.path(tempdir(), "fooPackage")) # FALSE
#'
#' @seealso For other nCompiler packaging tools, see \code{\link{writePackage}}
#'   and \code{\link{buildPackage}}. For more info on deleting a directory see
#'   \code{\link[base]{unlink}}.
erasePackage <- function(pkgName, dir = '.',
                         lib,
                         nCompilerOnly = TRUE,
                         unload = TRUE,
                         unregister = FALSE,
                         uninstall = FALSE,
                         quiet = FALSE,
                         error = TRUE
                         ) {
  if(unload && unregister) {
    if(error)
      stop("At most one of unload and unregister can be TRUE.")
    else unregister <- FALSE
  }
  pkgDir <- file.path(dir, pkgName)
  do_erase <- TRUE
  if (!dir.exists(pkgDir)) {
    do_erase <- FALSE
    if(error) stop(paste0("Directory does not exist at the specified path: ", pkgDir))
  }
  if (!file.exists(file.path(pkgDir, "DESCRIPTION"))) {
    do_erase <- FALSE
    if(error) stop("Target is not a package (no DESCRIPTION found).")
  }
  if (nCompilerOnly && do_erase) {
    desc <- read.dcf(file.path(pkgDir, "DESCRIPTION"))
    # following Writing R extensions notes for DESCRIPTION file, generate or
    # overwrite desc[,"Author"] if desc[,"Authors@R"] is present
    if("Authors@R" %in% colnames(desc)) {
      author = utils:::.read_authors_at_R_field(desc[,"Authors@R"])
      author = paste(author$given, author$family)
      if("Author" %in% colnames(desc)) {
        desc[,"Author"] = author
      } else {
        desc = cbind(desc, "Author" = author)
      }
    }
    if (!(desc[,"Author"] == "This package was generated by the nCompiler")) {
      do_erase <- FALSE
      if(error) stop("This package was not auto-generated by nCompiler.")
    }
  }

  try_unload_unreg <- TRUE
  if(!error) try_unload_unreg <- isNamespaceLoaded(pkgName) #any(grepl(pkgName, searchpaths()))

  if(try_unload_unreg) {
    if (unload)
      pkgload::unload(pkgName, quiet = quiet)
    #    detach(paste0("package:", pkgName), unload = TRUE, character.only=TRUE)
    if(unregister) { # unregister function does not have a quiet argument
      pkgload::unregister(pkgName)
    }
  }
  if(uninstall) {
    if(missing(lib)) {
      is_installed <- any(grepl(pkgNamed, installed.packages()))
      if(is_installed) devtools::uninstall(pkgName, quiet = quiet)
    } else {
      is_installed <- any(grepl(pkgNamed, installed.packages(lib.loc = lib)))
      if(is_installed) withr::with_libpaths(lib, action="prefix",
        code = devtools::uninstall(pkgName, quiet = quiet))
      #remove.packages(pkgName)
    }
  }
  if(do_erase) unlink(pkgDir, recursive = TRUE)
  invisible(NULL)
}



#' @name documentNClass
#' @title Produce a roxygen2 documentation text block for an nClass
#' @description Builds out a text block in roxygen2 format given the inputs. The
#'   user provides the name, title, and description, as well as a named list of
#'   descriptions of fields and a named list of methods descriptions.
#'   Optionally, the function can process whitespace and perform a check against
#'   the nClass generator object, reporting whether all fields and methods were
#'   described.
#' @param obj The nClass generator being documented. Only required if
#'   checkAgainstObj is TRUE, ignored otherwise.
#' @param name The nClass name. Used in the `@name` field of roxygen2
#'   documentation.
#' @param title a descriptive title for the nClass. Used in the `@title` field
#'   of roxygen2 documentation
#' @param description A text block giving a full and clear description of the
#'   nClass. For use in the `@description` field of roxyygen2 documentation. If
#'   processWhitespacpe is TRUE, any whitespace in the description will be
#'   ignored and the code block will be reformatted for style.
#' @param fields A named list of documentation for C-ready public fields
#'   belonging to the nClass. Fields are values stored internally by the class
#'   and that are publicly accessible with `obj$field`. List names should
#'   exactly match field names, while the elements of the list should be
#'   character strings describing the field.
#' @param CMethodsDescriptions A named list of descriptions for the nClass's
#'   methods. List names should exactly match method names, while the elements
#'   of the list should be character strings describing the method.
#' @param CMethodsParams A named list of named lists. The names in
#'   CMethodsParams should match exactly the names of the methods of the nClass.
#'   Each element of CMethodsParams should itself be a named list, with names
#'   matching parameters of the appropriate function, and elements being text
#'   strings describing those parameters.
#' @param otherRoxygen Additional roxygen content to be tacked onto the end of
#'   the roxygen2 header. This could be `@examples`, `@seealso`, or any other
#'   valid roxygen field. You are responsible for formatting these the way you
#'   want, including nwlines, `#'` comment notation, and `@@` prefixes.
#'   Character string, optional.
#' @param processWhitespace Logical, default TRUE. Can whitespace be modified to
#'   maintain style?
#' @param headerComment what string indicates the start of a roxygen comment for
#'   the header? By default nCompiler packaging puts header comments for
#'   nClasses in R, so the default value `#'` should almost always be kept.
#' @param methodsComment what string indicates the start of a roxygen comment
#'   for the methods? By default nCompiler packaging puts methods comments for
#'   nClasses in R, so the default value `#'` should almost always be kept.
#' @param checkAgainstObj Logical, default TRUE. Should the input be compared
#'   against the actual nClass generator to confirm that all elements have been
#'   documented appropriately? (NOTE: not implemented yet, currently ignored)
#' @seealso For documenting nFunctions see \link{documentNFunction}. For
#'   nCompiler packaging tools see \link{writePackage}. To learn about roxygen
#'   documentation format see the package roxygen, e.g.
#'   \link[roxygen2]{roxygenize}.
#'
#' @examples
#' # Initialize an example nClass
#' foo <- nClass(
#'   classname = "foo",
#'   Cpublic = list(
#'     x = "numericScalar",
#'     cp1 = nFunction(fun = function(x = numericScalar()) {
#'       x <<- x
#'       ans <- x + 1
#'       return(ans)
#'       returnType(numericScalar())
#'     }))
#' )
#' # Create the roxygen
#' rox <- documentNClass(obj = foo,
#'                       name  = "foo",
#'                       title = "A Test nClass",
#'                       description = "This nClass has a method to add 1
#'                          to a scalar input, and has a field to store
#'                          that input.",
#'                       fields = list(x = "A scalar input."),
#'                       CMethodsDescriptions = list(cp1 = "Adds 1 to x."),
#'                       CMethodsParams =
#'                         list(
#'                          cp1 = list(x = "A scalar to which 1 will be added.")
#'                         ),
#'                       methodsComment = "#'")
#' # Use the roxygen to write and build a package, which will include
#' # documentation for foo
#' writePackage(foo,
#'              dir = tempdir(),
#'              pkgName = "fooPackageWriteDocnFunction",
#'              roxygen = list(foo = rox))
#' buildPackage("fooPackageWriteDocnFunction",
#'              dir = tempdir(),
#'              roxygenize = TRUE)
#' ?foo
#' @export

# TODO: Be more thoughtful about when whitespace is and isn't addressed,
#       incl. tabs and the like
documentNClass <- function(obj = NULL, name, title, description = NULL,
                           fields = list(),
                           CMethodsDescriptions = list(),
                           CMethodsParams = list(),
                           otherRoxygen = NULL,
                           headerComment = "#'",
                           methodsComment = "#'",
                           processWhitespace = TRUE,
                           checkAgainstObj = FALSE) {
  # Check sanity of inputs
  if (sum(nchar(names(fields)) > 0) < length(fields)) {
    stop("in documentNClass: Some elements of list 'fields' are unnamed.")
  }
  if (checkAgainstObj && is.null(obj)) {
    stop(paste("in documentNClass: checkAgainstObj is true but no nClass",
               "object was provided"))
  }

  if (processWhitespace) {
    nameProc <- strwrap(gsub("[[:space:]]+", " ", name), width = 80,
                           prefix = paste0(headerComment, "   "),
                        initial = paste0(headerComment, " @name "))
    titleProc <- strwrap(gsub("[[:space:]]+", " ", title), width = 80,
                           prefix = paste0(headerComment, "   "),
                         initial = paste0(headerComment, " @title "))
    descProc <-
      if (is.null(description)) { NULL
      } else strwrap(gsub("[[:space:]]+", " ", description), width = 80,
                   prefix = paste0(headerComment, "   "),
                   initial = paste0(headerComment, " @description "))

    fieldsProc <- character(length(fields))
    if (length(fields) > 0) for (i in 1:length(fields)) {
      fieldsProc[i] <- strwrap(paste(names(fields)[i], fields[[i]]),
                               width = 80, prefix = paste0(headerComment, "   "),
                               initial = paste0(headerComment, " @field "))
    }

  } else {
    nameProc <- gsub("\n", paste0("\n", headerComment),
                     paste0(headerComment, " @name ", name))
    titleProc <- gsub("\n", paste0("\n", headerComment),
                      paste0(headerComment, " @title ", title))
    descProc <- gsub("\n", paste0("\n", headerComment),
                     paste0(headerComment, " @description ", description))
    fieldsProc <- character(length(fields))
    if (length(fields) > 0) for (i in 1:length(fields)) {
      fieldsProc[[i]] <- gsub("\n", paste0("\n", headerComment),
                              paste(headerComment, "@field", names(fields)[i],
                                    fields[[i]]))
    }
  }

  header <- paste0(c(nameProc, titleProc, descProc, fieldsProc, otherRoxygen),
                   collapse = "\n")


  # Handle the methods documentation.
  # Methods are allowed to have just description, just params, or both
  methodsToDocument <- unique(c(names(CMethodsDescriptions),
                                  names(CMethodsParams)))

  methodsList <- list()
  for (i in 1:length(methodsToDocument)) {
    thisMethod <- methodsToDocument[i]
    thisNameProc <- strwrap(gsub("[[:space:]]+", " ", thisMethod), width = 80,
                            prefix = paste0(methodsComment, "   "),
                            initial = paste0(methodsComment, " @name "))

    thisDescStr <- strwrap(gsub("[[:space:]]+", " ", CMethodsDescriptions[[thisMethod]]),
                           width = 80, prefix = paste0(methodsComment, "   "),
                           initial = paste0(methodsComment, " @description "))
    thisParams <- character(length(CMethodsParams[[thisMethod]]))
    for (j in 1:length(thisParams)) {
      thisParams[j] <- strwrap(gsub("[[:space:]]+", " ", CMethodsParams[[i]][j]),
                               width = 80, prefix = paste0(methodsComment, "   "),
                               initial = paste0(methodsComment, " @param ",
                                                names(CMethodsParams[[i]])[j],
                                                " "))
    }

    methodsList[[ methodsToDocument[i] ]] <-
      paste(
        c(thisDescStr, thisParams),
        collapse = "\n"
      )
  }

  return(list(header = header,
              methods = methodsList))
}


#' @name documentNFunction
#' @title Produce a roxygen2 documentation text block for an nFunction
#' @description Builds out a text block in roxygen2 format given the inputs. The
#'   user provides the name, title, and description, as well as a named list of
#'   descriptions of fields and a named list of methods descriptions.
#'   Optionally, the function can process whitespace and perform a check against
#'   the nFunction generator object, reporting whether all fields and methods
#'   were described.
#' @param obj The nFunction being documented. Only required if checkAgainstObj
#'   is TRUE, ignored otherwise.
#' @param name The nFunction name. Used in the `@name` field of roxygen2
#'   documentation.
#' @param title a descriptive title for the nClass. Used in the `@title` field
#'   of roxygen2 documentation
#' @param description A text block giving a full and clear description of the
#'   nClass. For use in the `@description` field of roxyygen2 documentation. If
#'   processWhitespacpe is TRUE, any whitespace in the description will be
#'   ignored and the code block will be reformatted for style.
#' @param params A named list. Names are the names of parameters in the
#'   nFunction. Values are descriptions of each parameter.
#' @param otherRoxygen Additional roxygen content to be tacked onto the end of
#'   the roxygen2 header. This could be `@examples`, `@seealso`, or any other
#'   valid roxygen field. You are responsible for formatting these the way you
#'   want, including nwlines, `#'` comment notation, and `@@` prefixes.
#'   Character string, optional.
#' @param processWhitespace Logical, default TRUE. Can whitespace be modified to
#'   maintain style?
#' @param roxComment what string indicates the start of a roxygen comment? By
#'   default nCompiler packaging puts comments for nFunctions in C++, so the
#'   default value `//'` should almost always be kept.
#' @param checkAgainstObj Logical, default TRUE. Should the input be compared
#'   against the actual nClass generator to confirm that all elements have been
#'   documented appropriately? (NOTE: not implemented yet, currently ignored)
#'
#' @export
#' @seealso For documenting nFunctions see \link{documentNFunction}. For
#'   nCompiler packaging tools see \link{writePackage}. To learn about roxygen
#'   documentation format see the package roxygen, e.g.
#'   \link[roxygen2]{roxygenize}.
#'
#' @examples
#' # Initialize an example nFunction
#' foo <- nFunction(name = "foo",
#'                  fun = function(x = numericScalar()) {
#'                      ans <- x+1
#'                      return(ans)
#'                      returnType(numericScalar())
#'                  })
#' # Create the roxygen
#' rox <- documentNFunction(obj = foo,
#'                     name  = "foo",
#'                     title = "A Test nFunction",
#'                     description = "This nFunction just adds 1 to a
#'                               scalar input.",
#'                     params = list(x = "A scalar to which 1 will be added."),
#'                     otherRoxygen = "//' @export")
#' # Use the roxygen to write and build a package, which will include
#' # documentation for foo
#' writePackage(foo,
#'              dir = tempdir(),
#'              pkgName = "fooPackageWriteDocnFunction",
#'              roxygen = list(foo = rox))
#' buildPackage("fooPackageWriteDocnFunction",
#'              dir = tempdir(),
#'              roxygenize = TRUE)
#' ?foo

# TODO: Be more thoughtful about when whitespace is and isn't addressed,
#       incl. tabs and the like
documentNFunction <- function(obj = NULL, name, title, description = NULL,
                              params = list(), otherRoxygen = NULL,
                              processWhitespace = TRUE, roxComment = "//'",
                              checkAgainstObj = FALSE){
  # Check sanity of inputs
  if (sum(nchar(names(params)) > 0) < length(params)) {
    stop("in documentNClass: Some elements of list 'params' are unnamed.")
  }
  if (checkAgainstObj && is.null(obj)) {
    stop(paste("in documentNClass: checkAgainstObj is true but no nFunction",
               "object was provided"))
  }

  if (processWhitespace) {

    nameProc <- strwrap(gsub("[[:space:]]+", " ", name), width = 80,
                        prefix = paste0(roxComment, "   "),
                        initial = paste0(roxComment, " @name "))
    titleProc <- strwrap(gsub("[[:space:]]+", " ", title), width = 80,
                         prefix = paste0(roxComment, "   "),
                         initial = paste0(roxComment, " @title "))
    descProc <-
      if (is.null(description)) { NULL
      } else strwrap(gsub("[[:space:]]+", " ", description), width = 80,
                     prefix = paste0(roxComment, "   "),
                     initial = paste0(roxComment, " @description "))

    paramsProc <- character(length(params))
    if (length(params) > 0) for (i in 1:length(params)) {
      paramsProc[i] <- strwrap(paste(names(params)[i], params[[i]]),
                               width = 80, prefix = paste0(roxComment, "   "),
                               initial = paste0(roxComment, " @param "))
    }

  } else {
    nameProc <- gsub("\n", paste0("\n", roxComment),
                     paste0(roxComment, " @name ", name))
    titleProc <- gsub("\n", paste0("\n", roxComment),
                      paste0(roxComment, " @title ", title))
    descProc <- gsub("\n", paste0("\n", roxComment),
                     paste0(roxComment, " @description ", description))
    fieldsProc <- character(length(params))
    if (length(params) > 0) for (i in 1:length(params)) {
      paramsProc[[i]] <- gsub("\n", paste0("\n", roxComment),
                              paste(roxComment, "@param",
                                    names(params)[i], params[[i]]))
    }
  }

  header <- paste0(c(nameProc, titleProc, descProc, paramsProc, otherRoxygen),
                   collapse = "\n")


  return(list(header = header))
}
