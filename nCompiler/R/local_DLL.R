## Manage creation of a local DLL for on-the-fly compilation to link against.

## TO-DO:
## Write uninstallLocalDLL (skeleton below).
## Perhaps re-name some functions below for consistency.

#' Create (but don't install) files for nCompLocal package
#' 
#' Write files and compile static library for nCompLocal package, whose purpose is to 
#' hold a static library (DLL) that on-the-fly compilation can link to.
#' 
#' @param dir Directory in which nCompLocal package files will be generated.
#' 
#' @details This function is called internally from \cite{\link{buildLocalDLLpackage}}.  
#' See there for explanation of the local DLL.
#' 
#' @seealso \cite{\link{buildLocalDLLpackage}}, \cite{\link{installLocalDLLpackage}}  
createLocalDLLpackage <- function(dir = '.',
                                  force = TRUE) {
  if(!require(pkgKitten, quietly = TRUE))
    stop("Package pkgKitten must be installed")
  if(dir.exists(file.path(dir, "nCompLocal"))) {
    message(paste0("When trying to create nCompLocal in directory ", dir,", a local directory named nCompLocal already exists."))
    userInput <- readline("Do you want to over-write it (Y or N): ")
    if(toupper(userInput) == "Y")
      unlink(file.path(dir, "nCompLocal"), recursive = TRUE)
  }
  showLocalDLLoutput <- isTRUE(get_nOption("showLocalDLLoutput"))
  if(!showLocalDLLoutput) {
    zz <- file("kitten_output_not_necessary.Rout", open = "wt")
    sink(zz)
    sink(zz, type = "message")
  }
  eval(
    substitute(
      kitten("nCompLocal",
             path = DIR,
             author = "This little package was generated by nCompiler to build a static library on your machine to link to nComp-generated libraries.", 
             maintainer = "This package was generated by nCompiler.",
             license = "See nCompiler",
             email = "not@available.org"),
      list(DIR = dir)),
    envir = .GlobalEnv)
  if(!showLocalDLLoutput) {
    sink()
    sink(type = "message")
    close(zz)
    if(file.exists("kitten_output_not_necessary.Rout"))
      file.remove("kitten_output_not_necessary.Rout")
  }
  NAMESPACE_file <- file.path(dir, "nCompLocal", "NAMESPACE")
  sink(NAMESPACE_file) # Wipe it clean so it doesn't try to export kitten stuff
  sink()
  DESCRIPTION_file <- file.path(dir, "nCompLocal", "DESCRIPTION")
  DESCRIPTION <- read.dcf(DESCRIPTION_file)
  DESCRIPTION[, "Version"] <- "0.1"
  DESCRIPTION[, "Title"] <- "Provides a library for static linking to on-the-fly nCompiler C++."
  DESCRIPTION[, "Description"] <- "nCompiler generates C++ from R and compiles it.  For some purposes, it is useful to link against code that has been compiled on each user's system.  Since nCompiler requires a C++ tool chain anyway, which should also be sufficient for installing a package from source, it is expected that each user's system can install this package.  You might think that compiled code for linking could be included in the nCompiler package itself, but this is surprisingly difficult and operating-system-dependent."
  write.dcf(DESCRIPTION, file = DESCRIPTION_file)
  staticLibPath <- file.path(dir, "nCompLocal", "inst", "staticLib")
  dir.create(staticLibPath, showWarnings = FALSE, recursive = TRUE)
  file.copy(system.file(file.path('nCompLocal_files','loadedObjectEnv.cpp'),
                        package = 'nCompiler'),
            staticLibPath)
  currentWarn <- getOption("rcpp.warnNoExports")
  options(rcpp.warnNoExports = FALSE)
  Rcpp::sourceCpp(file = file.path(staticLibPath, "loadedObjectEnv.cpp"),
                  showOutput = FALSE)
  options(rcpp.warnNoExports = currentWarn)
  ## Navigate through Rcpp's cache directory structure:
  cacheDir1 <- getOption("rcpp.cache.dir", tempdir()) ## where sourceCpp places files
  cacheDir1Files <- list.files(cacheDir1, full.names = TRUE)
  ## Determine the most recent directory name with "sourceCpp" in it.
  sourceCppDir1 <- cacheDir1Files[ grepl("sourceCpp", cacheDir1Files)]
  if (length(sourceCppDir1) > 1) {
    cppDir1_mtime <- file.mtime(sourceCppDir1)
    sourceCppDir1 <- sourceCppDir1[which.max(cppDir1_mtime)]
  }
  sourceCppDir1Files <- list.files(sourceCppDir1, full.names = TRUE)
  ## Determine the most recent subdirectory with the name "sourcecpp" (lower-case c) in it
  sourcecppDir2 <- sourceCppDir1Files[ grepl("sourcecpp", sourceCppDir1Files)]
  if (length(sourcecppDir2) > 1) {
    cppDir2_mtime <- file.mtime(sourcecppDir2)
    sourcecppDir2 <- sourcecppDir2[which.max(cppDir2_mtime)]
  }
  ## Build static library from the .o files left by Rcpp.
  ## This will need to be updated for windows
  if(.Platform$OS.type == "windows")
    message("Need to update the 'ar' call in createLocalDLLpackage for Windows.")
  system2("ar", c("rcs",
                  file.path(staticLibPath, "libnCompLocal.a"),
                  file.path(sourcecppDir2, "loadedObjectEnv.o")))
}

cleanupLocalDLLpackage <- function(dir = '.') {
  # Previously we removed the working directory of package creation.
  # This causes problems via the non-standard effects of pkgKitten
  # via tools it uses like pkgload.  A simple solution is to not remove the package source.
  # In normal working operation, this will be done in tempdir() so it 
  # will be cleaned up when R exits.
  #
  # We leave this currently empty step in the workflow in case we come up
  # with valid cleanup steps at some point.
  #
  #  if(dir.exists(dir))
  #    unlink(dir, recursive = TRUE)
}

#' Install nCompLocal package
#' 
#' Install the nCompLocal package, whose purpose is to hold a static library for linking from on-the-fly compilations.
#' 
#' @param lib location to install package.  This defaults to the first element of `.libPaths()`.  `lib` matches behavior, 
#' and is passed to, the \code{lib} argument of \link{install.packages}.
#' @param source.dir directory where nCompLocal source is located.
#' 
#' @details This function is used internally by This function is called internally from \cite{\link{buildLocalDLLpackage}}.
#' See there for explanation of the local DLL.
#' 
#' @seealso \cite{\link{buildLocalDLLpackage}}, \cite{\link{createLocalDLLpackage}}  
installLocalDLLpackage <- function(lib, source.dir = '.') {
  if(missing(lib)) lib <- .libPaths()[1]
  pkgs <- file.path(source.dir, "nCompLocal")
  utils::install.packages(pkgs,   # Rstudio / devtools takes over install.packages. use core R version.
                   lib = lib,
                   repos = NULL,
                   type = "source",
                   quiet = !isTRUE(get_nOption("showLocalDLLoutput")))
}

#' Create and install nCompLocal package
#' 
#' Create and install nCompLocal package, which contains a static dynamic library (DLL)
#' on each user's machine for nCompiler-generated C++ to link to.
#' 
#' @param dir directory where nCompLocal package will be created and possibly installed.  The default value 
#' can be controlled by setting the.nOption for \code{localDLLdir} (see \link{set_nOption}).
#' In turn, this option be default is NULL, in which case R's session-specific temporary directory (\code{tempdir()})
#' will be used.  If \code{installInR} is \code{FALSE}, then \code{dir} will also be the location of of the installed 
#' package.  In such a case, the nCompLocal package will be re-created once in every R session that compiled with nCompiler.
#' @param create.dir \code{TRUE} if \code{dir} needs to be created (in which case there will be an error if \code{dir} already exists).
#' @param installInR \code{TRUE} if nCompLocal should be installed as a regular package in R.  Generally, this is a 
#' good idea, as it means that nCompLocal only needs to be created and installed once per installation.  Otherwise
#' these steps may happen once per session, which will be the case if \code{dir} is \code{NULL}.  It is also possible 
#' to install nCompLocal to a directory provided by \code{get_nOption("localDLLdir")} and leave it there.  In that
#' case, nCompiler will automatially find it there in future R sessions.
#' 
#' @details See \link{setup_nCompLocal} for the simplest way to install nCompLocal, which is as a standard R
#' package in the standard location.  \code{buildLocalDLLpackage} provides more control over where it will be
#' installed and where package source files will be written.
#' 
#' @seealso \link{setup_nCompLocal}
#' 
#' @export
buildLocalDLLpackage <- function(dir = file.path(tempdir(), get_nOption("localDLLdir")),
                                 create.dir = TRUE,
                                 installInR = FALSE,
                                 cleanup = TRUE) {
  if(is.null(dir)) {
    dir <- tempdir()
    create.dir <- FALSE
  }
  if(create.dir) {
    if(dir.exists(dir))
      stop(paste0("While trying to install nCompLocal, directory ",
                  dir,
                  " already exists.  remove it and try again."))
    dir.create(dir, showWarnings = FALSE)
  }
  createLocalDLLpackage(dir = dir)
  if(!installInR) {
    lib.loc <- file.path(dir, "nCompLocalLibrary")
    if(dir.exists(lib.loc)) {
      message(paste0("While trying to install nCompLocal, the directory nCompLocalLibrary already exists in ", dir))
      userInput <- readline("Over-write nCompLocalLibrary (Y or N): ")
      if(toupper(userInput) == "Y")
        unlink("nCompLocalLibrary", recursive = TRUE)
    }
    dir.create(lib.loc, showWarnings = FALSE, recursive = TRUE)
  } else
    lib.loc <- .libPaths()[1]
  installLocalDLLpackage(lib = lib.loc, source.dir = dir)
  if(installInR & cleanup)
    cleanupLocalDLLpackage(dir = dir)
}


#' Create and install nCompLocal package as a regular R package.
#' 
#' Create and install nCompLocal package, which contains a static dynamic library (DLL)
#' on each user's machine for nCompiler-generated C++ to link to.
#'
#' @details nCompiler is faster and simpler if it can link on-the-fly C++ compilation to a static library
#' on each user's machine.  That static library is nCompLocal.  It is a somewhat unusual R package.  It
#' does not contain any R source code.  It does not contain the type of compiled shared library that packages
#' with C or C++ source code typically do.  Instead it contains a \code{staticLib} directory with a static
#' library.
#' 
#' A typical R package would not assume that a user's system has the compiler tools to build a package 
#' including C++ source code from source.  Since nCompiler requires compiler tools anyway, it is reasonable
#' to assume that dynamically building a package from source will work.
#' 
#' This function will install nCompLocal as a regular R package in the default location for packages.
#' For more control over where the package is installed, and where package source files are written, 
#' see \link{buildLocalDLLpackage}
#' 
#' @seealso \link{buildLocalDLLpackage}
#' 
#' @export
setup_nCompLocal <- function() {
  # This function builds and installs a package in R's standard location
  buildLocalDLLpackage(
    dir = file.path(tempdir(), "setup_nCompLocal_files"),
    installInR = TRUE)
}

#' Find and load, or possibly create, nCompLocal package.
#' 
#' nCompLocal is a package created and installed on each user's machine, sometimes or each R
#' session.  It contains a static library for nCompiler to link to.
#' 
#' @param lib optional location where nCompLocal is installed
#' @param buildIfMissing if \code{TRUE}, this function attempt to create nCompLocal if it can't be found.
#' 
#' @details This function is called internally every time nCompiler is ready to call the C++ compiler for
#' generated code.
#' 
#' @seealso \link{setup_nCompLocal} for how to create and install nCompLocal once for an
#' R installation, so that nCompLocal can be re-used than than re-created in every R session.
requireLocalDLLpackage <- function(lib, buildIfMissing = TRUE) {
  ## Check in order: provided lib, regular .libPaths(),nOptions(localDLLdir)
  if(isTRUE(get_nOption("localDLL_isLoaded")))
    return(TRUE)
  found <- FALSE
  if(!missing(lib))
    found <- require("nCompLocal", lib.loc = file.path(lib, "nCompLocalLibrary"), quietly = TRUE)
  if(!found)
    found <- require("nCompLocal", quietly = TRUE)
  if(!found) {
    localDLLdir <- file.path(tempdir(), get_nOption("localDLLdir"))
    if(!is.null(localDLLdir)) {
      if(dir.exists(localDLLdir))
        found <- require("nCompLocal", lib.loc = file.path(localDLLdir, "nCompLocalLibrary"), quietly = TRUE)
    }
  }
  if(found) {
    set_nOption("localDLL_isLoaded", TRUE)
    return(TRUE)
  } 
  if(buildIfMissing) {
    ok <- try({
      message(paste0("Creating nCompLocal package from nCompiler.  ",
                     "This happens once per session if necessary, or ",
                     "once-per-installation if you run \"setup_nCompLocal()\". ",
                     " See help(\"setup_nCompLocal\") for more information.  ",
                     "(There may be a spurious warning message, after this ",
                     "message, saying there is no nCompLocal package.) "))
      buildLocalDLLpackage()
      found <- require("nCompLocal", lib.loc = file.path(localDLLdir, "nCompLocalLibrary"), quietly = TRUE)
    })
    if(inherits(ok, "try-error") | !found)
      stop("There was a problem building the localDLL package.")
    TRUE
  } else {
    FALSE
  }
}

# This function is used by the nCompiler_Eigen_plugin for Rcpp.
# This plugin is invoked by "// [[Rcpp::plugins(nCompiler_Eigen_plugin)]]" C++ source code that is compiled via Rcpp::sourceCpp.
# The Rcpp plugin system allows packages to modify environment variables used as C++ compiler flags.
# This function is also called by buildPackage
get_nCompLocal_PGK_LIBS_entry <- function() {
  loc <- system.file(file.path('staticLib'), package = 'nCompLocal')
  ans <- paste0("-L \"", loc, "\" -lnCompLocal")
  ans
}
