########################
## Main AD testing utils
########################

## Take a test parameterization created by make_AD_test() or
## make_distribution_fun_AD_test(), generate a random input, and test for
## matching nimDerivs outputs from uncompiled and compiled versions of a
## nimbleFunction.
##
## param:              an test parameterization generated by make_AD_test() or
##                     make_distribution_fun_AD_test()
## dir:                passed to compileNimble() as the dirName argument
## control:            passed to compileNimble() as the control argument
## verbose:            if TRUE, print messages while testing
## catch_failures:     if TRUE, don't stop testing when a testthat expect_*
##                     fails
## seed:               seed to use in set.seed() before generating random inputs
## nimbleProject_name: passed to compileNimble() as the projectName argument
## return_compiled_nf: if TRUE, don't call clearCompiled() and include the
##                     compiled nimbleFunction instance in the output
##
## returns: a list with the randomly generated input and possibly the compiled
##          nimbleFunction instance, or NULL if the test has a known compilation
##          failure
##
## TODO: update argument descriptions
##
test_AD <- function(base_list, verbose = nimbleOptions('verbose'),
                    catch_failures = FALSE, control = list(), seed = 0,
                    nimbleProject_name = '', return_compiled_nf = FALSE,
                    knownFailures = list()) {
  # TODO: use debug flag from somewhere?
  # if (!is.null(param$debug) && param$debug) browser()

  param_list <- base_list$param_list
  nC <- base_list$nC

  ##
  ## compile the nClass 'nC'
  ##

  ## user provided compiled nimbleFunction?
  nC_compiled <- base_list$nC_compiled
  if (is.null(nC_compiled)) {
    if (verbose) cat("## Compiling nClass \n")

    nC_compiled <- try(
      nCompile_nClass(nC, control = control, interface = 'generic'),
      silent = TRUE
    )
  }
  if (inherits(nC_compiled, 'try-error')) {
    msg <- paste0(
      'The test of ', param$name, ' failed to compile.\n', CnfInst[1]
    )

    if (isTRUE(catch_failures)) {
      warning(msg, call. = FALSE, immediate. = TRUE)
      return(invisible(NULL))
    } else {
      stop(msg, call = FALSE)
    }
  }

  nC_obj <- nC_compiled()

  for (i in seq_along(param_list)) {

    param <- param_list[[i]]

    if (verbose) cat("## Testing ", param$name, "\n", sep = '')

    ## TODO: remove dependence on this Cpublic method naming convention
    nFun_i <- paste0('nFun', i)

    # reset the seed for every test
    if (is.numeric(seed)) set.seed(seed)

    ##
    ## generate inputs for the Cpublic methods
    ##
    if (is.null(param$input_gen_funs) || is.null(names(param$input_gen_funs)))
      if (length(param$input_gen_funs) <= 1)
        input <- lapply(param$argTypes, arg_type_2_input, param$input_gen_funs)
    else
      stop(
        'input_gen_funs of length greater than 1 must have names',
        call. = FALSE
      )
    else {
      input <- sapply(
        names(param$argTypes),
        function(name)
          arg_type_2_input(param$argTypes[[name]], param$input_gen_funs[[name]]),
        simplify = FALSE
      )
    }
    ##
    ## generate inputs that depend on the other inputs
    ##
    is_fun <- sapply(input, is.function)
    input[is_fun] <- lapply(
      input[is_fun], function(fun) {
        eval(as.call(c(fun, input[names(formals(fun))])))
      }
    )

    ##
    ## call R versions of nimbleFunction methods with generated input
    ##
    if (verbose)
      cat("## Calling uncompiled version of nClass method '",
          nFun_i, "'\n", sep = '')

    Rderivs <- try(
      lapply(param$wrts, function(wrt) {

        this_nf <- nC$public_methods[[nFun_i]]
        nCompiler:::nDerivs_nf(
          derivFxnCall = as.call(c(quote(this_nf), input)),
          wrt = wrt
        )
      }), silent = TRUE
    )
    if (inherits(Rderivs, 'try-error')) {
      msg <- paste(
        'Calling R version of test', param$name,
        'resulted in an error:\n', Rderivs[1]
      )
      if (isTRUE(catch_failures)) ## continue to compilation
        warning(msg, call. = FALSE, immediate. = TRUE)
      else
        stop(msg, call. = FALSE) ## throw an error here
    }

    Cval <- do.call(method(nC_obj, nFun_i), input)

    ##
    ## call Cpublic methods of compiled nClass with generated input
    ##
    if (verbose)
      cat("## Calling compiled version of nClass method '",
          nFun_i, "'\n", sep = '')

    Cderivs <- lapply(param$wrts, function(wrt) {

      gradient <- value(
        do.call(
          method(nC_obj, paste0(nFun_i, '_derivs_')),
          c(input, list(order = c(0, 1, 2), wrt = wrt))
        ),
        'gradient'
      )
      list(value = Cval, jacobian = gradient)
    })

    for (wrt in names(param$wrts)) {
      if (verbose)
        cat("## Testing equality of outputs for ", wrt, '\n')
      expect_equal( ## check values
        as.vector(Cderivs[[wrt]]$value),
        as.vector(Rderivs[[wrt]]$value)
      )
      expect_equal( ## check jacobians
        as.vector(Cderivs[[wrt]]$jacobian),
        as.vector(Rderivs[[wrt]]$jacobian)
      )
    }

    ## TODO: test hessian and distribution fun's log arg
    if (FALSE) {
      if ('log' %in% names(param$args)) {
        input2 <- input
        input2$log <- as.numeric(!input$log)
        Rderivs2 <- try(
          sapply(names(param$methods), function(method) {
            do.call(nfInst[[method]], input2)
          }, USE.NAMES = TRUE), silent = TRUE
        )
        Cderivs2 <- sapply(names(param$methods), function(method) {
          do.call(CnfInst[[method]], input2)
        }, USE.NAMES = TRUE)
      }
      
      ##
      ## loop over test methods (each with a different wrt arg)
      ##
      ## set expect_equal tolerances
      tol1 <- if (is.null(param$tol1)) 1e-8 else param$tol1
      tol2 <- if (is.null(param$tol1)) 1e-7 else param$tol2
      tol3 <- if (is.null(param$tol2)) 1e-6 else param$tol3
      for (method_name in names(param$methods)) {
        if (verbose) {
          cat(paste0(
            "## Testing ", method_name, ': ',
            paste0(param$wrts[[method_name]], collapse = ', '),
            '\n'
          ))
        }
        ##
        ## test values
        ##
        value_test_fails <- is_method_failure(
          param$name, method_name, 'value', knownFailures
        )
        value_test <- wrap_if_true(value_test_fails, expect_failure, {
          if (verbose) cat("## Checking values\n")
          expect_equal(
            Cderivs[[method_name]]$value,
            Rderivs[[method_name]]$value,
            tolerance = tol1
          )
          if ('log' %in% names(param$args)) {
            if (verbose) cat("## Checking log behavior for values\n")
            expect_equal(
              Cderivs2[[method_name]]$value,
              Rderivs2[[method_name]]$value,
              tolerance = tol1
            )
            expect_false(isTRUE(all.equal(
              Rderivs[[method_name]]$value,
              Rderivs2[[method_name]]$value,
              tolerance = tol1
            )))
            expect_false(isTRUE(all.equal(
              Cderivs[[method_name]]$value,
              Cderivs2[[method_name]]$value,
              tolerance = tol1
            )))
          }
        }, wrap_in_try = isTRUE(catch_failures))
        if (isTRUE(catch_failures) && inherits(value_test, 'try-error')) {
          warning(
            paste0(
              'There was something wrong with the values of ',
              param$name, ' with wrt = c(',
              paste0(param$wrts[[method_name]], collapse = ', '), ').\n',
              value_test[1]
            ),
            call. = FALSE,
            immediate. = TRUE
          )
        } else if (value_test_fails) {
          if (verbose) {
            cat(paste0(
              "## As expected, test of values failed for ", method_name, ' with wrt: ',
              paste0(param$wrts[[method_name]], collapse = ', '),
              '\n'
            ))
          }
          ## stop testing after an expected failure
          break
        }
        ##
        ## test jacobians
        ##
        jacobian_test_fails <- is_method_failure(
          param$name, method_name, 'jacobian', knownFailures
        )
        jacobian_test <- wrap_if_true(jacobian_test_fails, expect_failure, {
          if (verbose) cat("## Checking jacobians\n")
          expect_equal(
            Cderivs[[method_name]]$jacobian,
            Rderivs[[method_name]]$jacobian,
            tolerance = tol2
          )
          if ('log' %in% names(param$args)) {
            if (verbose) cat("## Checking log behavior for jacobians\n")
            expect_equal(
              Cderivs2[[method_name]]$jacobian,
              Rderivs2[[method_name]]$jacobian,
              tolerance = tol2
            )
            expect_false(isTRUE(all.equal(
              Rderivs[[method_name]]$jacobian,
              Rderivs2[[method_name]]$jacobian,
              tolerance = tol2
            )))
            expect_false(isTRUE(all.equal(
              Cderivs[[method_name]]$jacobian,
              Cderivs2[[method_name]]$jacobian,
              tolerance = tol2
            )))
          }
        }, wrap_in_try = isTRUE(catch_failures))
        if (isTRUE(catch_failures) && inherits(jacobian_test, 'try-error')) {
          warning(
            paste0(
              'There was something wrong with the jacobian of ',
              param$name, ' with wrt = c(',
              paste0(param$wrts[[method_name]], collapse = ', '), ').\n',
              jacobian_test[1]
            ),
            call. = FALSE,
            immediate. = TRUE
          )
        } else if (jacobian_test_fails) {
          if (verbose) {
            cat(paste0(
              "## As expected, test of jacobian failed for ", method_name, ' with wrt: ',
              paste0(param$wrts[[method_name]], collapse = ', '),
              '\n'
            ))
          }
          ## stop testing after an expected failure
          break
        }
        ##
        ## test hessians
        ##
        hessian_test_fails <- is_method_failure(
          param$name, method_name, 'hessian', knownFailures
        )
        hessian_test <- wrap_if_true(hessian_test_fails, expect_failure, {
          if (verbose) cat("## Checking hessians\n")
          expect_equal(
            Cderivs[[method_name]]$hessian,
            Rderivs[[method_name]]$hessian,
            tolerance = tol3
          )
          if ('log' %in% names(param$args)) {
            if (verbose) cat("## Checking log behavior for hessians\n")
            expect_equal(
              Cderivs2[[method_name]]$hessian,
              Rderivs2[[method_name]]$hessian,
              tolerance = tol3
            )
            expect_false(isTRUE(all.equal(
              Rderivs[[method_name]]$hessian,
              Rderivs2[[method_name]]$hessian,
              tolerance = tol3
            )))
            expect_false(isTRUE(all.equal(
              Cderivs[[method_name]]$hessian,
              Cderivs2[[method_name]]$hessian,
              tolerance = tol3
            )))
          }
        }, wrap_in_try = isTRUE(catch_failures))
        if (isTRUE(catch_failures) && inherits(hessian_test, 'try-error')) {
          warning(
            paste0(
              'There was something wrong with the hessian of ',
              param$name, ' with wrt = c(',
              paste0(param$wrts[[method_name]], collapse = ', '), ').\n',
              hessian_test[1]
            ),
            call. = FALSE,
            immediate. = TRUE
          )
        } else if (hessian_test_fails) {
          if (verbose) {
            cat(paste0(
              "## As expected, test of hessian failed for ", method_name, ' with wrt: ',
              paste0(param$wrts[[method_name]], collapse = ', '),
              '\n'
            ))
          }
          ## stop testing after an expected failure
          break
        }
      }
      if (verbose) cat("### Test successful \n\n")
      if (return_compiled_nf)
        invisible(list(CnfInst = CnfInst, input = input))
      else if(!compilation_fails) {
        nimble:::clearCompiled(CnfInst)
        invisible(list(input = input))
      }
    } ## if (FALSE) {
  }
  invisible(NULL)
}

#########################################
## AD test parameterization builder utils
#########################################

## Takes a named list of `argTypes` and returns a list of character
## vectors, each of which is valid as the `wrt` argument of `nimDerivs()`.
## Each argument on its own and all combinations of the arguments will
## always be included, and then make_wrt will try to create up to `n_random`
## additional character vectors with random combinations of the arguments
## and indexing of those arguments when possible (i.e. for non-scalar args).
## n_arg_reps determines how many times an argument can be used in a given
## wrt character vector. By default, any argument will appear only 1 time.
make_wrt <- function(argTypes, n_random = 10, n_arg_reps = 1) {

  ## always include each arg on its own, and all combinations of the args
  wrts <- as.list(names(argTypes))
  if (length(argTypes) > 1)
    for (m in 2:length(argTypes)) {
      this_combn <- combn(names(argTypes), m)
      wrts <- c(
        wrts,
        unlist(apply(this_combn, 2, list), recursive = FALSE)
      )
    }

  argSymbols <- lapply(
    argTypes, function(argType)
      add_missing_size(nCompiler:::argType2symbol(argType))
  )

  while (n_random > 0) {
    n_random  <- n_random - 1
    n <- sample(1:length(argTypes), 1) # how many of the args to use?
    ## grab a random subset of the args of length n
    args <- sample(argSymbols, n)
    ## may repeat an arg up to n_arg_reps times
    reps <- sample(1:n_arg_reps, length(args), replace = TRUE)
    this_wrt <- c()
    for (i in 1:length(args)) {
      while (reps[i] > 0) {
        reps[i] <- reps[i] - 1
        ## coin flip determines whether to index vectors/matrices
        use_indexing <- sample(c(TRUE, FALSE), 1)
        if (use_indexing && args[[i]]$nDim > 0) {
          rand_row <- sample(1:args[[i]]$size[1], size = 1)
          ## another coin flip determines whether to use : in indexing or not
          use_colon <- sample(c(TRUE, FALSE), 1)
          if (use_colon && rand_row < args[[i]]$size[1]) {
            end_row <- rand_row +
              sample(1:(args[[i]]$size[1] - rand_row), size = 1)
            rand_row <- paste0(rand_row, ':', end_row)
          }
          index <- rand_row
          if (args[[i]]$nDim == 2) {
            rand_col <- sample(1:args[[i]]$size[2], size = 1)
            ## one more coin flip to subscript second dimension
            use_colon_again <- sample(c(TRUE, FALSE), 1)
            if (use_colon_again && rand_col < args[[i]]$size[2]) {
              end_col <- rand_col +
                sample(1:(args[[i]]$size[2] - rand_col), size = 1)
              rand_col <- paste0(rand_col, ':', end_col)
            }
            index <- paste0(index, ',', rand_col)
          }
          this_wrt <- c(this_wrt, paste0(names(args)[i], '[', index, ']'))
        }
        ## if first coin flip was FALSE, just
        ## use the arg name without indexing
        else this_wrt <- c(this_wrt, names(args)[i])
      }
    }
    if (!is.null(this_wrt)) wrts <- c(wrts, list(unique(this_wrt)))
  }
  wrts <- unique(wrts)
  names(wrts) <- paste0('wrt: ', sapply(wrts, paste, collapse = ', '))
  wrts
}

## Make a test parameterization to be used by test_AD. This method is primarily
## used by make_AD_test_batch() and make_distribution_fun_AD_test().
##
## op:             Character string, the operator that will be the focus of the
##                 test.
## argTypes:       Character vector of argType strings that, when parsed, can be
##                 passed to argType2symbol. If named, the names will as the formals
##                 of the nimbleFunction generator's run method and other methods.
##                 If not, formals are generated as arg1, arg2, etc.
## wrt_args:       Optional character vector of args to use in make_wrt(). If NULL,
##                 assumes that all the arguments should be used.
## input_gen_funs: A list of input generation functions which is simply passed to
##                 the output list. Should be NULL (use defaults found in
##                 arg_type_2_input()), length 1 (use same input gen mechanism for each
##                 argType, or a named list with names from among the argType names
##                 (possibly the sequentially generated names). This will be NULL
##                 when bulk generating the test params using make_AD_test_batch and
##                 added later via modify_on_match(). Used in the call to
##                 make_AD_test() in make_distribution_fun_AD_test(). 
## more_args:      A named list of additional fixed arguments to use in the
##                 generated operator call. E.g., if op = 'dnorm',
##                 argTypes = c('double(1, 5)', 'double(0)'), and
##                 more_args = list(log = 1), the call to make_op_param will include
##                 the expression dnorm(arg1, arg2, log = 1).
## seed:           A seed to use in set.seed().
##
## returns: A list with the following elements:
##          name:           from make_op_param
##          expr:           from make_op_param
##          argTypes:       from make_op_param
##          returnType:     from make_op_param
##          wrts:           a list of character vectors, each of which is the wrt
##                          argument for the corresponding method in methods
##          input_gen_funs: A list of random input generation functions to be
##                          used by arg_type_2_input(). 
make_AD_test <- function(op, argTypes, wrt_args = NULL,
                         input_gen_funs = NULL, more_args = NULL, seed = 0) {
  ## set the seed for make_wrt
  if (is.numeric(seed)) set.seed(seed)
  opParam <- make_op_param(op, argTypes, more_args)

  if (is.null(wrt_args)) wrt_args_filter <- rep(TRUE, length(argTypes))
  else wrt_args_filter <- wrt_args
  wrts <- make_wrt(opParam$argTypes[wrt_args_filter])

  invisible(
    c(opParam,
      list(
        wrts = wrts,
        input_gen_funs = input_gen_funs,
        enableDerivs = TRUE))
  )
}

## ops: character vector of operator names
## argTypes: list of character vectors of argTypes
##           e.g. for a binary operator:
##             list(
##               c('double(1, 4)', 'double(0)'),
##               c('double(1, 4)', 'double(1, 4)')
##             )
make_AD_test_batch <- function(ops, argTypes, seed = 0) {
  batch_of_ops <- sapply(
    ops,
    function(x) {
      op_tests <- mapply(
        make_AD_test,
        argTypes = argTypes,
        MoreArgs = list(op = x, seed = seed),
        SIMPLIFY = FALSE
      )
      names(op_tests) <- sapply(op_tests, `[[`, 'name')
      op_tests
    },
    simplify = FALSE
  )
  invisible(batch_of_ops)
}

## Takes an element of distn_params list and returns a list of AD test
## parameterizations, each of which test_AD can use.
##
## distn_param: Probability distribution parameterization, which
##              must have the following fields/subfields:
##              - name
##              - variants
##              - args
##                - rand_variate
##                  - type
##              Additional args must also have type field.
## more_args:   Passed to make_op_param().
##
make_distribution_fun_AD_test <- function(distn_param) {
  distn_name <- distn_param$name
  ops <- sapply(distn_param$variants, paste0, distn_name, simplify = FALSE)

  rand_variate_idx <- which(names(distn_param$args) == 'rand_variate')

  argTypes <- sapply(distn_param$variants, function(variant) {
    op <- paste0(variant, distn_name)
    rand_variate_type <- distn_param$args$rand_variate$type
    first_argType <- switch(
      variant,
      d = rand_variate_type,
      p = rand_variate_type,
      q = c('double(0)')##, 'double(1, 4)')
    )
    first_arg_name <- switch(variant, d = 'x', p = 'q', q = 'p')
    ## need this complicated expand.grid call here because the argTypes might be
    ## character vectors (e.g. if rand_variate_type is c("double(0)", "double(1, 4)")
    ## then we create a test where we sample a scalar from the support and
    ## another where we sample a vector of length 4 from the support
    grid <- eval(as.call(c(
      expand.grid, list(first_argType),
      lapply(distn_param$args, `[[`, 'type')[-rand_variate_idx]
    )))
    argTypes <- as.list(data.frame(t(grid), stringsAsFactors=FALSE))
    lapply(argTypes, function(v) {
      names(v) <- c(
        first_arg_name,
        names(distn_param$args[-rand_variate_idx])
      )
      v
    })
  }, simplify = FALSE)
  input_gen_funs <- lapply(distn_param$args[-rand_variate_idx], `[[`, 'input_gen_fun')
  input_gen_funs_list <- sapply(distn_param$variants, function(variant) {
    arg1_input_gen_fun <- switch(
      variant,
      d = list(x = distn_param$args$rand_variate$input_gen_fun),
      p = list(q = distn_param$args$rand_variate$input_gen_fun),
      q = list(p = runif)
    )
    c(arg1_input_gen_fun, input_gen_funs)
  }, simplify = FALSE)
  op_params <- unlist(
    lapply(
      distn_param$variants, function(variant) {
        lapply(
          argTypes[[variant]],
          function(these_argTypes) {
            wrt_args = intersect(
              distn_param$wrt, names(these_argTypes)
            )
            make_AD_test(
              ops[[variant]], these_argTypes,
              wrt_args = wrt_args,
              input_gen_funs = input_gen_funs_list[[variant]],
              more_args = distn_param$more_args[[variant]]
            )
          }
        )
      }
    ), recursive = FALSE
  )
  names(op_params) <- sapply(op_params, `[[`, 'name')
  return(op_params)
}

#############################
## input generation functions
#############################

## arg_size comes from arg$size where arg is a symbolBasic object
gen_pos_def_matrix <- function(arg_size) {
  m <- arg_size[1] ## assumes matrix argType is square
  mat <- diag(1:m)
  mat[lower.tri(mat)] <- runif(m*(m - 1)/2)
  mat %*% t(mat)
}

#######################
## old AD testing utils
#######################

# TODO: delete when ready

test_AD_old <- function(param, info = '', size = 3,
                    dir = file.path(tempdir(), "nCompiler_generatedCode"),
                    control = list(), verbose = nOptions('verbose'),
                    debug = nOptions('compilerOptions')[['debug']],
                    compile_all_funs = FALSE, ...) {
  if (!is.null(param$debug) && param$debug || debug) browser()

  nC <- gen_nClass(param)
  set_nOption('automaticDerivatives', TRUE)

  if (compile_all_funs) {
    nFuns <- param$Cpublic
    ## useful for debugging an nClass compilation failure
    ## e.g. test_AD(ADopTests[['- numericVector']], compile_all_funs = TRUE)
    for (name in names(nFuns)) {
      if (verbose)
        cat(paste('### Compiling function for test of:', name, '###\n'))
      nCompile_nFunction(nFuns[[name]])
    }
  }

  info <- paste0(info, ": compiles")
  ## need expect_error not expect_failure(expect_something()) because otherwise
  ## R error will stop execution
  wrap_if_matches(param$knownFailure, info, expect_error, {
    args <- sapply(param$argTypes, make_input, size = size, USE.NAMES = FALSE)
    if (verbose) cat("## Compiling nClass ##\n")
    if (!is.null(param$dir)) dir <- param$dir
    compiled_nC <- nCompile_nClass(nC, dir = dir, control = control, interface = "generic")
    expect_true(is.function(compiled_nC)) ## compilation succeeded

    info <- paste0(info, ": runs")
    wrap_if_matches(param$knownFailure, info, expect_failure, {
      obj <- compiled_nC()
      expect_true(nCompiler:::is.loadedObjectEnv(obj))
      for (i in seq_along(param$enableDerivs)) {
        fun_i <- param$enableDerivs[i]
        nF_i <- nC$public_methods[[fun_i]]
        expect_equal(method(obj, fun_i)(args[i]), nF_i(args[i]))
        # in the future this will be able to take a 3rd arg for wrt
        derivs <- method(obj, paste0(fun_i, "_derivs_"))(args[i], c(0, 1))
        expect_true(nCompiler:::is.loadedObjectEnv(derivs))
        value(derivs, "gradient")
        ## expect_equal(value(derivs, "gradient"), )
      }
      if (verbose) cat("### -------------------------------------------- ###\n")

    })
  })
  invisible(NULL)
}

makeADtest <- function(op, argType, size = 3) {
  opParam <- makeOperatorParam(op, argType)
  name <- opParam$name
  isBinary <- nCompiler:::getOperatorDef(op, 'testthat', 'isBinary')
  isUnary <- nCompiler:::getOperatorDef(op, 'testthat', 'isUnary')
  if (!is.null(isBinary) && isBinary) {
    binaryOpParam1 <- binaryOpParam2 <- opParam
    tmp <- binaryOpParam2$expr[[3]][[2]]
    ## put in a constant as the other arg
    binaryOpParam1$expr[[3]][[3]] <- binaryOpParam2$expr[[3]][[2]] <- 1.5
    ## put back in variable arg as second arg in binaryOpParam2
    binaryOpParam2$expr[[3]][[3]] <- tmp
    name1 <- paste(name, 1.5)
    binaryOpParam1$name <- name1
    name2 <- paste(op, 1.5, argType)
    binaryOpParam2$name <- name2
    opParams <- list(binaryOpParam1, binaryOpParam2)
  }
  if (!is.null(isUnary) && isUnary) {
    if (exists('opParams', inherits = FALSE)) opParams[[3]] <- opParam
    else opParams <- list(opParam)
  }
  if (!exists('opParams', inherits = FALSE))
    stop(
      paste0('Something\'s wrong... Operator ', op,
             ' is neither unary nor binary.'),
      call. = FALSE
    )
  nFuns <- lapply(opParams, function(param) {
    if (param$argTypes$arg1 == 'numericVector') {
      typeString <- paste0('numericVector(length = ', size, ')')
      param$argTypes$arg1 <- typeString
      param$returnType <- typeString
    }
    nFun <- gen_nFunction(param)
    nFun
  })
  names(nFuns) <- paste0('nFun', 1:length(nFuns))
  list(
    name = name,
    argTypes = rep(argType, length(nFuns)),
    Rpublic = list(),
    Cpublic = nFuns,
    enableDerivs = names(nFuns)
  )
}
